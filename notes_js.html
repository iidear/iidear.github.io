<!DOCTYPE html>
<html>
<head>
<title>读书笔记</title>
<meta charset="utf-8" />
<meta http-equiv="cache-control" content="no-cache" />
<meta name="Author" content="iidear" />
<link rel="stylesheet" href="style.css" />
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ffbe20012ef4cb34b0eae3f55ba51a50";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
</head>
<body>
<!--  @main-navigation
------------------------------------------------------------------>
<nav role="navigation">
<ul id="mainNav">
    <li><a href="index.html">首页</a></li>
	<li><a href="notes.html">笔记</a></li>
	<li><a href="books.html">书单</a></li>
	<li><a href="about.html">关于我</a></li>
</ul>
</nav>
<!--  @content
------------------------------------------------------------------>
<div class="content" id="js">
	<article id="js_1">
		<h3>2015-3-23 小结</h3>
		<section>
			<h4>对JavaScript语言的认识</h4>
			<ul>
				<li>JavaScript = ECMAScript + DOM + BOM;</li>
				<li>JavaScript是基于对象的语言;</li>
				<li>JavaScript负责浏览器端的交互行为;</li>
				<li>通过API构建丰富应用.</li>
			</ul>
		</section>
		<section>
			<h4>对JavaScript语言的掌握</h4>
			<ul>
				<li>JavaScript对象的创建,原型链与继承;</li>
				<li>JavaScript的执行环境,作用域和闭包;</li>
				<li>DOM原生JavaScript操作;</li>
				<li>事件流和事件处理;</li>
				<li>HTML 5添加的API;</li>
				<li>Ajax:XMLHttpRequest对象;</li>
				<li>jQuery选择器;</li>
				<li>正则表达式.</li>
			</ul>
		</section>
		<section>
			<h4>有待提高</h4>
			<ul>
				<li><a href="https://github.com/JacksonTian/fks" target="_blank">前端技能汇总</a></li>
				<li><a href="http://www.zhihu.com/question/19554845" target="_blank">怎样成长为一个优秀的 Web 前端开发工程师？</a></li>
				<li><a href="http://www.zhihu.com/question/20790576" target="_blank">大公司里怎样开发和部署前端代码？</a></li>
				<li><a href="http://stackoverflow.com/questions/2628672/what-should-every-javascript-programmer-know" target="_blank">What should every JavaScript programmer know?</a></li>
			</ul>
		</section>
	</article>
	<article id="js_2">
		<h3>JavaScript核心</h3>
		<section>
			<h4>对象Object</h4>
			<p>An object is a collection of properties and has a single prototype object. The prototype may be either an object or the null value.<br />
			Object是一个属性的集合，并且都拥有一个单独的原型对象[prototype object]. 这个原型对象[prototype object]可以是一个object或者null值。</p>
		</section>
		<section>
			<h4>原型链（Prototype chain）</h4>
			<p>A prototype chain is a finite chain of objects which is used to implemented inheritance and shared properties.</br>
			原型链是一个由对象组成的有限对象链用于实现继承和共享属性。</p>
			<p>原型对象也是普通的对象，并且也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链（prototype chain）。</p>
		</section>
		<section>
			<h4>构造函数(Constructor)</h4>
			<p>除了创建对象，构造函数(constructor) 还做了另一件有用的事情—自动为创建的新对象设置了原型对象(prototype object) 。原型对象存放于 ConstructorFunction.prototype 属性中。</p>
		</section>
		<section>
			<h4>执行上下文栈(Execution Context Stack)</h4>
			<p>当一段程序开始时，会先进入全局执行上下文环境[global execution context], 这个也是堆栈中最底部的元素。此全局程序会开始初始化，初始化生成必要的对象[objects]和函数[functions]. 在此全局上下文执行的过程中，它可能会激活一些方法（当然是已经初始化过的），然后进入他们的上下文环境，然后将新的元素压入堆栈。在这些初始化都结束之后，这个系统会等待一些事件（例如用户的鼠标点击等），会触发一些方法，然后进入一个新的上下文环境。</p>
		</section>
		<section>
			<h4>执行上下文(Execution Context)</h4>
			<p>一个执行的上下文可以抽象的理解为object。每一个执行的上下文都有一系列的属性（我们称为上下文状态），他们用来追踪关联代码的执行进度。<br />
			除了3个所需要的属性(变量对象(variable object)，this指针(this value)，作用域链(scope chain) )，执行上下文根据具体实现还可以具有任意额外属性。接着，让我们仔细来看看这三个属性。
			</p>
			<section>
				<h4>变量对象(Variable Object)</h4>
				<p>A variable object is a scope of data related with the execution context. <br />
				It’s a special object associated with the context and which stores variables and function declarations are being defined within the context.<br />
				变量对象(variable object) 是与执行上下文相关的 数据作用域(scope of data) 。<br />
				它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。</p>
				<p>注意：函数表达式[function expression]（而不是函数声明[function declarations]）是不包含在VO[variable object]里面的。<br />
				在一个函数上下文中，变量对象被表示为活动对象(activation object)。</p>
			</section>
			<section>
				<h4>活动对象(activation object)</h4>
				<p>当函数被调用者激活，这个特殊的活动对象(activation object) 就被创建了。它包含普通参数(formal parameters) 与特殊参数(arguments)对象(具有索引属性的参数映射表)。活动对象在函数上下文中作为变量对象使用。</p>
			</section>
			<section>
				<h4>作用域链(Scope Chains)</h4>
				<p>A scope chain is a list of objects that are searched for identifiers appear in the code of the context.<br />
				作用域链是一个 对象列表(list of objects) ，用以检索上下文代码中出现的 标识符(identifiers) 。</p>
				<p>标示符[Identifiers]可以理解为变量名称、函数声明和普通参数。</p>
				<p>在一般情况下，一个作用域链包括父级变量对象（variable object）（作用域链的顶部）、函数自身变量VO和活动对象（activation object）。不过，有些情况下也会包含其它的对象，例如在执行期间，动态加入作用域链中的—例如with或者catch语句。[译注：with-objects指的是with语句，产生的临时作用域对象；catch-clauses指的是catch从句，如catch(e)，这会产生异常对象，导致作用域变更]。</p>
				<p>当查找标识符的时候，会从作用域链的活动对象部分开始查找，然后(如果标识符没有在活动对象中找到)查找作用域链的顶部，循环往复，就像作用域链那样。</p>
				<p>在代码执行过程中，如果使用with或者catch语句就会改变作用域链。而这些对象都是一些简单对象，他们也会有原型链。这样的话，作用域链会从两个维度来搜寻:首先在原本的作用域链,然后每一个链接点的作用域的链（如果这个链接点是有prototype的话）</p>
			</section>
			<section>
				<h4>闭包(Closures)</h4>
				<p>只要所有外部函数的变量对象都存在，那么从内部函数引用外部数据则没有特别之处——我们只要遍历作用域链表，查找所需变量。然而，如上文所提及，当一个上下文终止之后，其状态与自身将会被 销毁(destroyed) ，同时内部函数将会从外部函数中返回。此外，这个返回的函数之后可能会在其他的上下文中被激活，那么如果一个之前被终止的含有一些自由变量的上下文又被激活将会怎样?通常来说，解决这个问题的概念在ECMAScript中与作用域链直接相关，被称为 (词法)闭包((lexical) closure)。</p>
				<p>Scope chain = Activation object + [[Scope]]<br />
				作用域链 = 活动对象 + [[Scope]]</p>
				<p>我们似乎可以断定，在语言中，使用静态作用域是闭包的一个强制性要求。不过，在某些语言中，会提供动态和静态作用域的结合，可以允许开发员选择哪一种作用域。但是在ECMAScript中，只采用了静态作用域。所以ECMAScript完全支持使用[[Scope]]的属性。我们可以给闭包得出如下定义：<br />
				A closure is a combination of a code block (in ECMAScript this is a function) and statically/lexically saved all parent scopes.<br />
				Thus, via these saved scopes a function may easily refer free variables.<br />
				闭包是一系列代码块（在ECMAScript中是函数），并且静态保存所有父级的作用域。通过这些保存的作用域来搜寻到函数中的自由变量。</p>
				<p>请注意，因为每一个普通函数在创建时保存了[[Scope]]，理论上，ECMAScript中所有函数都是闭包。<br />
				还有一个很重要的点，几个函数可能含有相同的父级作用域（这是一个很普遍的情况，例如有好几个内部或者全局的函数）。在这种情况下，在[[Scope]]中存在的变量是会共享的。一个闭包中变量的变化，也会影响另一个闭包的。</p>
			</section>
		</section>
		<section>
			<h4>This指针</h4>
			<p>A this value is a special object which is related with the execution context. <br />
			Therefore, it may be named as a context object (i.e. an object in which context the execution context is activated).<br />
			this是和执行的上下文环境息息相关的一个特殊对象。因此，它也可以称为上下文对象[context object](激活执行上下文的上下文)。</p>
			<p>a this value is a property of the execution context, but not a property of the variable object.<br />
			this是执行上下文环境的一个属性，而不是某个变量对象的属性。</p>
		</section>
		<h4>原文: http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html</h4>
	</article>
</div>
<!--  @navigation-aside
----------------------------------------------------------------->
<nav>
<ul id="rightNav">
	<li>交互设计
		<ul>
			<li><a href="notes.html#design_1">瞬间之美</a></li>
		</ul>
	</li>
	<li>HTML+CSS
		<ul>
			<li><a href="notes_html.html">HTML,CSS常见问题</a></li>
		</ul>
	</li>
	<li>JavaScript
		<ul>
			<li><a href="notes_js.html">学习之路</a></li>
			<li><a href="#js_2">JavaScript核心</a></li>
		</ul>
	</li>
	<li>Web性能
		<ul>
			<li></li>
		</ul>
	</li>
</ul>
</nav>
</body>
</html>